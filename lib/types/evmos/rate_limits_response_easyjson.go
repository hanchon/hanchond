// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package evmos

import (
	json "encoding/json"
	easyjson "github.com/mailru/easyjson"
	jlexer "github.com/mailru/easyjson/jlexer"
	jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
	_ *json.RawMessage
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ easyjson.Marshaler
)

func easyjsonEc4d4a2dDecodeGithubComHanchonHanchondLibTypesEvmos(in *jlexer.Lexer, out *RateLimitsResponse) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "rate_limits":
			if in.IsNull() {
				in.Skip()
				out.RateLimits = nil
			} else {
				in.Delim('[')
				if out.RateLimits == nil {
					if !in.IsDelim(']') {
						out.RateLimits = make([]struct {
							Path struct {
								Denom     string `json:"denom"`
								ChannelID string `json:"channel_id"`
							} `json:"path"`
							Quota struct {
								MaxPercentSend string `json:"max_percent_send"`
								MaxPercentRecv string `json:"max_percent_recv"`
								DurationHours  string `json:"duration_hours"`
							} `json:"quota"`
							Flow struct {
								Inflow       string `json:"inflow"`
								Outflow      string `json:"outflow"`
								ChannelValue string `json:"channel_value"`
							} `json:"flow"`
						}, 0, 0)
					} else {
						out.RateLimits = []struct {
							Path struct {
								Denom     string `json:"denom"`
								ChannelID string `json:"channel_id"`
							} `json:"path"`
							Quota struct {
								MaxPercentSend string `json:"max_percent_send"`
								MaxPercentRecv string `json:"max_percent_recv"`
								DurationHours  string `json:"duration_hours"`
							} `json:"quota"`
							Flow struct {
								Inflow       string `json:"inflow"`
								Outflow      string `json:"outflow"`
								ChannelValue string `json:"channel_value"`
							} `json:"flow"`
						}{}
					}
				} else {
					out.RateLimits = (out.RateLimits)[:0]
				}
				for !in.IsDelim(']') {
					var v1 struct {
						Path struct {
							Denom     string `json:"denom"`
							ChannelID string `json:"channel_id"`
						} `json:"path"`
						Quota struct {
							MaxPercentSend string `json:"max_percent_send"`
							MaxPercentRecv string `json:"max_percent_recv"`
							DurationHours  string `json:"duration_hours"`
						} `json:"quota"`
						Flow struct {
							Inflow       string `json:"inflow"`
							Outflow      string `json:"outflow"`
							ChannelValue string `json:"channel_value"`
						} `json:"flow"`
					}
					easyjsonEc4d4a2dDecode(in, &v1)
					out.RateLimits = append(out.RateLimits, v1)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonEc4d4a2dEncodeGithubComHanchonHanchondLibTypesEvmos(out *jwriter.Writer, in RateLimitsResponse) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"rate_limits\":"
		out.RawString(prefix[1:])
		if in.RateLimits == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v2, v3 := range in.RateLimits {
				if v2 > 0 {
					out.RawByte(',')
				}
				easyjsonEc4d4a2dEncode(out, v3)
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v RateLimitsResponse) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonEc4d4a2dEncodeGithubComHanchonHanchondLibTypesEvmos(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v RateLimitsResponse) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonEc4d4a2dEncodeGithubComHanchonHanchondLibTypesEvmos(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *RateLimitsResponse) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonEc4d4a2dDecodeGithubComHanchonHanchondLibTypesEvmos(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *RateLimitsResponse) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonEc4d4a2dDecodeGithubComHanchonHanchondLibTypesEvmos(l, v)
}
func easyjsonEc4d4a2dDecode(in *jlexer.Lexer, out *struct {
	Path struct {
		Denom     string `json:"denom"`
		ChannelID string `json:"channel_id"`
	} `json:"path"`
	Quota struct {
		MaxPercentSend string `json:"max_percent_send"`
		MaxPercentRecv string `json:"max_percent_recv"`
		DurationHours  string `json:"duration_hours"`
	} `json:"quota"`
	Flow struct {
		Inflow       string `json:"inflow"`
		Outflow      string `json:"outflow"`
		ChannelValue string `json:"channel_value"`
	} `json:"flow"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "path":
			easyjsonEc4d4a2dDecode1(in, &out.Path)
		case "quota":
			easyjsonEc4d4a2dDecode2(in, &out.Quota)
		case "flow":
			easyjsonEc4d4a2dDecode3(in, &out.Flow)
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonEc4d4a2dEncode(out *jwriter.Writer, in struct {
	Path struct {
		Denom     string `json:"denom"`
		ChannelID string `json:"channel_id"`
	} `json:"path"`
	Quota struct {
		MaxPercentSend string `json:"max_percent_send"`
		MaxPercentRecv string `json:"max_percent_recv"`
		DurationHours  string `json:"duration_hours"`
	} `json:"quota"`
	Flow struct {
		Inflow       string `json:"inflow"`
		Outflow      string `json:"outflow"`
		ChannelValue string `json:"channel_value"`
	} `json:"flow"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"path\":"
		out.RawString(prefix[1:])
		easyjsonEc4d4a2dEncode1(out, in.Path)
	}
	{
		const prefix string = ",\"quota\":"
		out.RawString(prefix)
		easyjsonEc4d4a2dEncode2(out, in.Quota)
	}
	{
		const prefix string = ",\"flow\":"
		out.RawString(prefix)
		easyjsonEc4d4a2dEncode3(out, in.Flow)
	}
	out.RawByte('}')
}
func easyjsonEc4d4a2dDecode3(in *jlexer.Lexer, out *struct {
	Inflow       string `json:"inflow"`
	Outflow      string `json:"outflow"`
	ChannelValue string `json:"channel_value"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "inflow":
			out.Inflow = string(in.String())
		case "outflow":
			out.Outflow = string(in.String())
		case "channel_value":
			out.ChannelValue = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonEc4d4a2dEncode3(out *jwriter.Writer, in struct {
	Inflow       string `json:"inflow"`
	Outflow      string `json:"outflow"`
	ChannelValue string `json:"channel_value"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"inflow\":"
		out.RawString(prefix[1:])
		out.String(string(in.Inflow))
	}
	{
		const prefix string = ",\"outflow\":"
		out.RawString(prefix)
		out.String(string(in.Outflow))
	}
	{
		const prefix string = ",\"channel_value\":"
		out.RawString(prefix)
		out.String(string(in.ChannelValue))
	}
	out.RawByte('}')
}
func easyjsonEc4d4a2dDecode2(in *jlexer.Lexer, out *struct {
	MaxPercentSend string `json:"max_percent_send"`
	MaxPercentRecv string `json:"max_percent_recv"`
	DurationHours  string `json:"duration_hours"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "max_percent_send":
			out.MaxPercentSend = string(in.String())
		case "max_percent_recv":
			out.MaxPercentRecv = string(in.String())
		case "duration_hours":
			out.DurationHours = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonEc4d4a2dEncode2(out *jwriter.Writer, in struct {
	MaxPercentSend string `json:"max_percent_send"`
	MaxPercentRecv string `json:"max_percent_recv"`
	DurationHours  string `json:"duration_hours"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"max_percent_send\":"
		out.RawString(prefix[1:])
		out.String(string(in.MaxPercentSend))
	}
	{
		const prefix string = ",\"max_percent_recv\":"
		out.RawString(prefix)
		out.String(string(in.MaxPercentRecv))
	}
	{
		const prefix string = ",\"duration_hours\":"
		out.RawString(prefix)
		out.String(string(in.DurationHours))
	}
	out.RawByte('}')
}
func easyjsonEc4d4a2dDecode1(in *jlexer.Lexer, out *struct {
	Denom     string `json:"denom"`
	ChannelID string `json:"channel_id"`
}) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "denom":
			out.Denom = string(in.String())
		case "channel_id":
			out.ChannelID = string(in.String())
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonEc4d4a2dEncode1(out *jwriter.Writer, in struct {
	Denom     string `json:"denom"`
	ChannelID string `json:"channel_id"`
}) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"denom\":"
		out.RawString(prefix[1:])
		out.String(string(in.Denom))
	}
	{
		const prefix string = ",\"channel_id\":"
		out.RawString(prefix)
		out.String(string(in.ChannelID))
	}
	out.RawByte('}')
}
